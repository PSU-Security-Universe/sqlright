\set invalid/name foo\set AUTOCOMMIT foo\set FETCH_COUNT foo\echo :ON_ERROR_ROLLBACK\set ON_ERROR_ROLLBACK\echo :ON_ERROR_ROLLBACK\set ON_ERROR_ROLLBACK foo\echo :ON_ERROR_ROLLBACK\set ON_ERROR_ROLLBACK on\echo :ON_ERROR_ROLLBACK\unset ON_ERROR_ROLLBACK\echo :ON_ERROR_ROLLBACKSELECT 1 as one, 2 as two \g\gxSELECT 3 as three, 4 as four \gx\g\set FETCH_COUNT 1SELECT 1 as one, 2 as two \g\gxSELECT 3 as three, 4 as four \gx\g\unset FETCH_COUNTSELECT 1 as one, 2 as two \g (format=csv csv_fieldsep='\t')\gSELECT 1 as one, 2 as two \gx (title='foo bar')\gselect 10 as test01, 20 as test02, 'Hello' as test03 \gset pref01_\echo :pref01_test01 :pref01_test02 :pref01_test03select 10 as "bad name"\gsetselect 97 as "EOF", 'ok' as _foo \gset IGNORE\echo :IGNORE_foo :IGNOREEOFselect 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_xselect 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_yselect 5 as x, 6 as y \gset pref01_ \\ \g \echo :pref01_x :pref01_yselect 7 as x, 8 as y \g \gset pref01_ \echo :pref01_x :pref01_y\set var2 xyzselect 1 as var1, NULL as var2, 3 as var3 \gset\echo :var1 :var2 :var3select 10 as test01, 20 as test02 from generate_series(1,3) \gsetselect 10 as test01, 20 as test02 from generate_series(1,0) \gset\set FETCH_COUNT 1select 1 as x, 2 as y \gset pref01_ \\ \echo :pref01_xselect 3 as x, 4 as y \gset pref01_ \echo :pref01_x \echo :pref01_yselect 10 as test01, 20 as test02 from generate_series(1,3) \gsetselect 10 as test01, 20 as test02 from generate_series(1,0) \gset\unset FETCH_COUNTSELECT    NULL AS zero,    1 AS one,    2.0 AS two,    'three' AS three,     1 AS four,    sin( 2) as five,    'foo'::varchar(4) as six,    CURRENT_DATE AS now\gdescPREPARE test AS SELECT 1 AS first, 2 AS second;
EXECUTE test \gdescEXPLAIN EXECUTE test \gdescSELECT 1 + \gdescSELECT \gdescCREATE TABLE bububu(a int) \gdescTABLE bububu;
  SELECT 1 AS x, 'Hello', 2 AS y, true AS "dirty\name"\gdesc\gSELECT 3 AS x, 'Hello', 4 AS y, true AS "dirty\name" \gdesc \gcreate temporary table gexec_test(a int, b text, c date, d float);
  SELECT 1 AS x, 'Hello', 2 AS y, true AS "dirty\name"\gdesc\gSELECT 3 AS x, 'Hello', 4 AS y, true AS "dirty\name" \gdesc \gcreate temporary table gexec_test(a int, b text, c date, d float);
select format('create index on gexec_test(%I)', attname)from pg_attributewhere attrelid = 'gexec_test'::regclass and attnum > 0order by attnum\gexec\set FETCH_COUNT 1select 'select 1 as ones', 'select x.y, x.y*2 as double from generate_series(1,4) as x(y)'union allselect 'drop table gexec_test', NULLunion allselect 'drop table gexec_test', 'select ''2000-01-01''::date as party_over'\gexec\unset FETCH_COUNT\psetprepare q as select array_to_string(array_agg(repeat('x',2*n)),E'\n') as "abc", array_to_string(array_agg(repeat('y',20-2*n)),E'\n') as "abc" from generate_series(1,10) as n(n) group by n>1 order by n>1;
\pset linestyle ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset expanded on\pset columns 20\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset linestyle old-ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset expanded on\pset columns 20\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
deallocate q;
prepare q as select repeat('x',2*n) as "0123456789abcdef", repeat('y',20-2*n) as "0123456789" from generate_series(1,10) as n;
\pset linestyle ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset expanded on\pset columns 30\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset expanded on\pset columns 20\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset linestyle old-ascii\pset expanded off\pset columns 40\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset expanded on\pset border 0\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 1\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
\pset border 2\pset format unalignedexecute q;
\pset format alignedexecute q;
\pset format wrappedexecute q;
deallocate q;
\pset linestyle ascii\pset border 1create table psql_serial_tab (id serial);
\pset format aligned\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only falseselect 1 where false;
\pset format unaligned\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset format wrapped\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only falseCREATE ACCESS METHOD heap_psql TYPE TABLE HANDLER heap_tableam_handler;
CREATE TABLE tbl_heap_psql(f1 int, f2 char(100)) using heap_psql;
CREATE TABLE tbl_heap(f1 int, f2 char(100)) using heap;
\d+ tbl_heap_psql\d+ tbl_heap\set HIDE_TABLEAM off\d+ tbl_heap_psql\d+ tbl_heap\set HIDE_TABLEAM onDROP TABLE tbl_heap, tbl_heap_psql;
DROP ACCESS METHOD heap_psql;
\pset format aligned\pset expanded off\pset numericlocale trueselect n, -n as m, n * 111 as x, '1e90'::float8 as ffrom generate_series(0,3) n;
\pset numericlocale false\pset format asciidoc\pset border 1\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only falseprepare q as  select 'some|text' as "a|title", '        ' as "empty ", n as int  from generate_series(1,2) as n;
\pset expanded off\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset expanded on\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
deallocate q;
\pset format csv\pset border 1\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only falseprepare q as  select 'some"text' as "a""title", E'  <foo>\n<bar>' as "junk",         '   ' as "empty", n as int  from generate_series(1,2) as n;
\pset expanded offexecute q;
\pset expanded onexecute q;
deallocate q;
\pset expanded offselect 'comma,comma' as comma, 'semi;
semi' as semi;
semi' as semi;
\pset csv_fieldsep ';
'select 'comma,comma' as comma, 'semi;
'select 'comma,comma' as comma, 'semi;
semi' as semi;
semi' as semi;
select '\.' as data;
\pset csv_fieldsep '.'select '\' as d1, '' as d2;
\pset csv_fieldsep ''\pset csv_fieldsep '\0'\pset csv_fieldsep '\n'\pset csv_fieldsep '\r'\pset csv_fieldsep '"'\pset csv_fieldsep ',,'\pset csv_fieldsep ','\pset format html\pset border 1\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only falseprepare q as  select 'some"text' as "a&title", E'  <foo>\n<bar>' as "junk",         '   ' as "empty", n as int  from generate_series(1,2) as n;
\pset expanded off\pset border 0execute q;
\pset border 1execute q;
\pset tableattr foobarexecute q;
\pset tableattr\pset expanded on\pset border 0execute q;
\pset border 1execute q;
\pset tableattr foobarexecute q;
\pset tableattrdeallocate q;
\pset format latex\pset border 1\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only falseprepare q as  select 'some\more_text' as "a title", E'  #<foo>%&^~|\n{bar}' as "junk",         '   ' as "empty", n as int  from generate_series(1,2) as n;
\pset expanded off\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset border 3execute q;
\pset expanded on\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset border 3execute q;
deallocate q;
\pset format latex-longtable\pset border 1\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only falseprepare q as  select 'some\more_text' as "a title", E'  #<foo>%&^~|\n{bar}' as "junk",         '   ' as "empty", n as int  from generate_series(1,2) as n;
\pset expanded off\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset border 3execute q;
\pset tableattr lrexecute q;
\pset tableattr\pset expanded on\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset border 3execute q;
\pset tableattr lrexecute q;
\pset tableattrdeallocate q;
\pset format troff-ms\pset border 1\pset expanded off\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only false\pset expanded on\d psql_serial_tab_id_seq\pset tuples_only true\df exp\pset tuples_only falseprepare q as  select 'some\text' as "a\title", E'  <foo>\n<bar>' as "junk",         '   ' as "empty", n as int  from generate_series(1,2) as n;
\pset expanded off\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
\pset expanded on\pset border 0execute q;
\pset border 1execute q;
\pset border 2execute q;
deallocate q;
\pset format a\pset format ldrop table psql_serial_tab;
\pset format aligned\pset expanded off\pset border 1\echo this is a test\echo -n without newline\echo with -n newline\echo '-n' with newline\set foo bar\echo foo = :foo\qecho this is a test\qecho foo = :foo\warn this is a test\warn foo = :foo\if true  select 'okay';
  select 'still okay';
\else  not okay;
  still not okay\endif\gselect  \if true    42  \else    (bogus  \endif  forty_two;
select \if false \\ (bogus \else \\ 42 \endif \\ forty_two;
\if true	\if 1		\if yes			\if on				\echo 'all true'			\else				\echo 'should not print #1-1'			\endif		\else			\echo 'should not print #1-2'		\endif	\else		\echo 'should not print #1-3'	\endif\else	\echo 'should not print #1-4'\endif\if false	\echo 'should not print #2-1'\elif 0	\echo 'should not print #2-2'\elif no	\echo 'should not print #2-3'\elif off	\echo 'should not print #2-4'\else	\echo 'all false'\endif\if true	\echo 'should print #2-5'\elif true	\echo 'should not print #2-6'\elif false	\echo 'should not print #2-7'\else	\echo 'should not print #2-8'\endif\if true	\echo 'first thing true'\else	\echo 'should not print #3-1'\endif\if false	\echo 'should not print #4-1'\elif true	\echo 'second thing true'\else	\echo 'should not print #5-1'\endif\if invalid boolean expression	\echo 'will not print #6-1'\else	\echo 'will print anyway #6-2'\endif\endif\else\elif\if true\else\else\endif\if false\else\elif\endif\if false    \if false        \echo 'should not print #7-1'    \else        \echo 'should not print #7-2'    \endif    \echo 'should not print #7-3'\else    \echo 'should print #7-4'\endif\set foo bar\echo :foo :'foo' :"foo"\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo"\set try_to_quit '\\q'\if false	:try_to_quit	\echo `nosuchcommand` :foo :'foo' :"foo"	\pset fieldsep | `nosuchcommand` :foo :'foo' :"foo"	\a	\C arg1	\c arg1 arg2 arg3 arg4	\cd arg1	\conninfo	\copy arg1 arg2 arg3 arg4 arg5 arg6	\copyright	SELECT 1 as one, 2, 3 \crosstabview	\dt arg1	\e arg1 arg2	\ef whole_line	\ev whole_line	\echo arg1 arg2 arg3 arg4 arg5	\echo arg1	\encoding arg1	\errverbose	\f arg1	\g arg1	\gx arg1	\gexec	SELECT 1 AS one \gset	\h	\?	\html	\i arg1	\ir arg1	\l arg1	\lo arg1 arg2	\lo_list	\o arg1	\p	\password arg1	\prompt arg1 arg2	\pset arg1 arg2	\q	\reset	\s arg1	\set arg1 arg2 arg3 arg4 arg5 arg6 arg7	\setenv arg1 arg2	\sf whole_line	\sv whole_line	\t arg1	\T arg1	\timing arg1	\unset arg1	\w arg1	\watch arg1	\x arg1		\w |/no/such/file \else		\! whole_line \endif	\z\else	\echo 'should print #8-1'\endif\set i 1\if :{?i}  \echo '#9-1 ok, variable i is defined'\else  \echo 'should not print #9-2'\endif\if :{?no_such_variable}  \echo 'should not print #10-1'\else  \echo '#10-2 ok, variable no_such_variable is not defined'\endifSELECT :{?i} AS i_is_defined;
SELECT NOT :{?no_such_var} AS no_such_var_is_not_defined;
\set SHOW_CONTEXT neverdo begin  raise notice 'foo';
  raise exception 'bar';
end ;
\set SHOW_CONTEXT errorsdo begin  raise notice 'foo';
  raise exception 'bar';
end ;
\set SHOW_CONTEXT alwaysdo begin  raise notice 'foo';
  raise exception 'bar';
end ;
SELECT 1;
\pSELECT 2 \r\pSELECT 3 \pUNION SELECT 4 \pUNION SELECT 5ORDER BY 1;
\r\pSELECT 1 AS stuff UNION SELECT 2;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNTSELECT 1 UNION;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATEDROP TABLE this_table_does_not_exist;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE\set VERBOSITY terseSELECT 1 UNION;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'last error message:' :LAST_ERROR_MESSAGE\set VERBOSITY sqlstateSELECT 1/0;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'last error message:' :LAST_ERROR_MESSAGE\set VERBOSITY defaultSELECT 3 AS three, 4 AS four \gdesc\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNTSELECT 4 AS \gdesc\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE\set FETCH_COUNT 10select unique2 from tenk1 order by unique2 limit 19;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNTselect 1/(15-unique2) from tenk1 order by unique2 limit 19;
\echo 'error:' :ERROR\echo 'error code:' :SQLSTATE\echo 'number of rows:' :ROW_COUNT\echo 'last error message:' :LAST_ERROR_MESSAGE\echo 'last error code:' :LAST_ERROR_SQLSTATE\unset FETCH_COUNTcreate schema testpart;
create role regress_partitioning_role;
alter schema testpart owner to regress_partitioning_role;
set role to regress_partitioning_role;
set search_path to testpart;
create table testtable_apple(logdate date);
create table testtable_orange(logdate date);
create index testtable_apple_index on testtable_apple(logdate);
create index testtable_orange_index on testtable_orange(logdate);
create table testpart_apple(logdate date) partition by range(logdate);
create table testpart_orange(logdate date) partition by range(logdate);
create index testpart_apple_index on testpart_apple(logdate);
create index testpart_orange_index on testpart_orange(logdate);
\dP test*apple*\dPt test*apple*\dPi test*apple*drop table testtable_apple;
drop table testtable_orange;
drop table testpart_apple;
drop table testpart_orange;
create table parent_tab (id int) partition by range (id);
create index parent_index on parent_tab (id);
create table child_0_10 partition of parent_tab  for values from (0) to (10);
create table child_10_20 partition of parent_tab  for values from (10) to (20);
create table child_20_30 partition of parent_tab  for values from (20) to (30);
insert into parent_tab values (generate_series(0,29));
create table child_30_40 partition of parent_tabfor values from (30) to (40)  partition by range(id);
create table child_30_35 partition of child_30_40  for values from (30) to (35);
create table child_35_40 partition of child_30_40   for values from (35) to (40);
insert into parent_tab values (generate_series(30,39));
\dPt\dPi\dP testpart.*\dP\dPtn\dPin\dPn\dPn testpart.*drop table parent_tab cascade;
drop schema testpart;
set search_path to default;
set role to default;
drop role regress_partitioning_role;

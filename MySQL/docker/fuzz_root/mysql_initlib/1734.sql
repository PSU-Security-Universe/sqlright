SELECT @@max_heap_table_size INTO @old_max_heap_table_size;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
DROP TABLE no_such_table;
SHOW ERRORS;
SHOW WARNINGS;
SHOW COUNT(*) ERRORS;
SHOW COUNT(*) WARNINGS;
GET DIAGNOSTICS @n = NUMBER;
GET DIAGNOSTICS CONDITION 1 @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
SELECT @n, @err_no, @err_txt;
DROP TABLE no_such_table;
SELECT @@error_count;
SELECT @@error_count;
DROP TABLE no_such_table;
SELECT @@warning_count;
SELECT @@warning_count;
CREATE TABLE IF NOT EXISTS t2 (f1 INT);
CREATE TABLE IF NOT EXISTS t2 (f1 INT);
SELECT @@warning_count;
DROP TABLE t2;
DROP TABLE no_such_table;
GET DIAGNOSTICS;
GET DIAGNOSTICS @n = NUMBER;
GET DIAGNOSTICS CONDITION 1 @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT;
SELECT @n, @err_no, @err_txt;
SET GLOBAL wombat = 'pangolin';
CREATE PROCEDURE p0_proc_with_warning () BEGIN SELECT CAST('2001-01-01' AS SIGNED INT); END;
CREATE PROCEDURE p6_bubble_warning () BEGIN DECLARE CONTINUE HANDLER FOR NOT FOUND BEGIN /* Absurdly high CONDITION number will cause GET DIAG to fail. As it is the last statement, warning should bubble up to caller. */ GET DIAGNOSTICS CONDITION 99 @e6 = MYSQL_ERRNO, @t6 = MESSAGE_TEXT; END; SET @n2 = 0, @e2 = 0, @t2 = 'handler was not run or GET DIAGNOSTICS failed'; SIGNAL SQLSTATE '02000' SET MESSAGE_TEXT = 'signal message'; END;
CREATE PROCEDURE p3_non_diagnostics_stmt_clears () BEGIN DECLARE CONTINUE HANDLER FOR NOT FOUND BEGIN /* Do some stuff before using GET (CURRENT, not STACKED) DIAGNOSTICS. This will clear the DA. show that handler was run, even if GET DIAG below fails! */ SET @t3 = 'handler was run, but GET DIAGNOSTICS failed'; SELECT 1 FROM DUAL; GET CURRENT DIAGNOSTICS @n3 = NUMBER; GET CURRENT DIAGNOSTICS CONDITION 1 @e3 = MYSQL_ERRNO, @t3 = MESSAGE_TEXT; END; SET @n3 = 0, @e3 = 0, @t3 = 'handler was not run or GET DIAGNOSTICS failed'; SIGNAL SQLSTATE '02000' SET MESSAGE_TEXT = 'signal message'; /* Show handler was called. */ SELECT @n3, @e3, @t3; END;
CREATE PROCEDURE p4_unhandled_exception_returned () BEGIN /* This will throw an exception which we do not handle, so execution will abort, and the caller will see the error. */ DROP TABLE no_such_table; SELECT "we should never get here"; END;
CREATE PROCEDURE p7_show_warnings () BEGIN SHOW VARIABLES LIKE 'foo'; SHOW WARNINGS; SELECT "(SHOW WARNINGS does not have to come last)"; END;
CREATE PROCEDURE p8a_empty () BEGIN END;
CALL p0_proc_with_warning;
DROP PROCEDURE p0_proc_with_warning;
CALL p1_declare_handler_preserves;
DROP PROCEDURE p1_declare_handler_preserves;
CALL p2_declare_variable_clears;
DROP PROCEDURE p2_declare_variable_clears;
CALL p5_declare_variable_clears;
DROP PROCEDURE p5_declare_variable_clears;
CALL p6_bubble_warning;
DROP PROCEDURE p6_bubble_warning;
CALL p3_non_diagnostics_stmt_clears;
DROP PROCEDURE p3_non_diagnostics_stmt_clears;
CALL p4_unhandled_exception_returned;
DROP PROCEDURE p4_unhandled_exception_returned;
CALL p7_show_warnings;
DROP PROCEDURE p7_show_warnings;
DROP TABLE no_such_table;
CALL p8a_empty;
SHOW WARNINGS;
DROP PROCEDURE p8a_empty;
DROP TABLE no_such_table;
CALL p8b_show_warnings;
DROP PROCEDURE p8b_show_warnings;
CREATE FUNCTION f2_unseen_warnings() RETURNS INT BEGIN /* throw a warning */ SET @@max_heap_table_size= 1; /* RETURN counts as a statement as per the standard, so clears DA */ RETURN 1; END;
CREATE FUNCTION f3_stacking_warnings() RETURNS TEXT BEGIN /* throw a warning */ RETURN CAST('2001-01-01' AS SIGNED INT); END;
SELECT f2_unseen_warnings();
SHOW WARNINGS;
SET @@max_heap_table_size= 1;
DROP FUNCTION f2_unseen_warnings;
SELECT f3_stacking_warnings(),f3_stacking_warnings(),f3_stacking_warnings();
DROP FUNCTION f3_stacking_warnings;
PREPARE stmt1 FROM 'create table if not exists t1 (f1 int)';
EXECUTE stmt1;
EXECUTE stmt1;
DEALLOCATE PREPARE stmt1;
DROP TABLE t1;
PREPARE stmt1 FROM 'create table if not exists t1 (f1 int)';
EXECUTE stmt1;
CREATE PROCEDURE p10_ps_with_warning () BEGIN DECLARE CONTINUE HANDLER FOR 1050 SELECT "a warn place"; EXECUTE stmt1; END;
CALL p10_ps_with_warning ();
DROP PROCEDURE p10_ps_with_warning;
DEALLOCATE PREPARE stmt1;
DROP TABLE t1;
PREPARE stmt1 FROM 'create table if not exists t1 (f1 year)';
EXECUTE stmt1;
EXECUTE stmt1;
DEALLOCATE PREPARE stmt1;
DROP TABLE t1;
SET @sql1='GET DIAGNOSTICS CONDITION 1 @err_no = MYSQL_ERRNO, @err_txt = MESSAGE_TEXT';
PREPARE stmt1 FROM @sql1;
PREPARE stmt2 FROM 'SHOW WARNINGS';
PREPARE stmt2 FROM 'SHOW ERRORS';
PREPARE stmt2 FROM 'SHOW COUNT(*) WARNINGS';
PREPARE stmt2 FROM 'SHOW COUNT(*) ERRORS';
PREPARE stmt2 FROM 'SELECT @@warning_count';
PREPARE stmt2 FROM 'SELECT @@error_count';
SET @@max_heap_table_size= 1;
SELECT 1;
SHOW WARNINGS;
SET @@max_heap_table_size= 1;
SELECT 1 FROM (SELECT 1) t1;
SHOW WARNINGS;
CREATE PROCEDURE peter1 () BEGIN DECLARE v INTEGER DEFAULT 1234; DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN SHOW WARNINGS; SELECT "handler done: ",v; END; CREATE TABLE gg (smallint_column SMALLINT); CALL peter2(v); END;
CREATE PROCEDURE peter2 (INOUT v INTEGER) BEGIN INSERT INTO gg (smallint_column) VALUES (32769); GET DIAGNOSTICS v = ROW_COUNT; END;
CALL peter1();
DROP PROCEDURE peter2;
DROP PROCEDURE peter1;
DROP TABLE gg;
SET @var="foo";
CALL peter3("bar");
DROP PROCEDURE peter3;
CREATE TABLE t3 (id INT NOT NULL);
CREATE PROCEDURE bug15231_1() BEGIN DECLARE xid INTEGER; DECLARE xdone INTEGER DEFAULT 0; DECLARE CONTINUE HANDLER FOR NOT FOUND SET xdone = 1; SET xid=NULL; CALL bug15231_2a(xid); SELECT "1,0", xid, xdone; SET xid=NULL; CALL bug15231_2b(xid); SELECT "NULL, 1", xid, xdone; END;
CREATE PROCEDURE bug15231_2a(INOUT ioid INTEGER) BEGIN SELECT "Before NOT FOUND condition is triggered" AS '1'; SELECT id INTO ioid FROM t3 WHERE id=ioid; SELECT "After NOT FOUND condtition is triggered" AS '2'; IF ioid IS NULL THEN SET ioid=1; END IF; END;
CALL bug15231_1();
DROP PROCEDURE bug15231_1;
DROP PROCEDURE bug15231_2a;
DROP PROCEDURE bug15231_2b;
CREATE PROCEDURE bug15231_3() BEGIN DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'Caught it (correct)' AS 'Result'; CALL bug15231_4(); END;
CREATE PROCEDURE bug15231_4() BEGIN DECLARE x DECIMAL(2,1); SET x = 'zap'; SHOW WARNINGS; END;
CALL bug15231_3();
CREATE PROCEDURE bug15231_5() BEGIN DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'Caught it (wrong)' AS 'Result'; CALL bug15231_6(); END;
CREATE PROCEDURE bug15231_6() BEGIN DECLARE x DECIMAL(2,1); SET x = 'zap'; SELECT id FROM t3; END;
CALL bug15231_5();
CREATE PROCEDURE bug15231_7() BEGIN DECLARE EXIT HANDLER FOR SQLEXCEPTION SELECT 'Caught it (right)' AS 'Result'; CALL bug15231_8(); END;
CREATE PROCEDURE bug15231_8() BEGIN DROP TABLE no_such_table; SELECT 'Caught it (wrong)' AS 'Result'; END;
